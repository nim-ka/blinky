<!DOCTYPE HTML>
<html>
	<head>
		<title> Blinky </title>

		<meta charset="utf-8" />

		<script>
			const ops = {};

			function getLen(bytecode) {
				let len = 8;

				while (len < bytecode.length) {
					if (
						bytecode[len - 8] == 0xFF &&
						bytecode[len - 7] == 0xFF &&
						bytecode[len - 6] == 0xFF &&
						bytecode[len - 5] == 0xFF &&
						bytecode[len - 4] == 0xFF &&
						bytecode[len - 3] == 0xFF &&
						bytecode[len - 2] == 0xFF &&
						bytecode[len - 1] == 0xFF) {
						break;
					}

					len++;
				}

				return len;
			}

			function getCrc(bytecode, len) {
				let crc = 0;

				for (let i = 1; i < len; i++) {
					crc ^= bytecode[i];

					for (let j = 0; j < 8; j++) {
						if (crc & 0x80) {
							crc = (crc << 1) & 0xff;
							crc ^= 0x31;
						} else {
							crc = (crc << 1) & 0xff;
						}
					}
				}

				return crc;
			}

			function assemble(str) {
				const bytecode = [0x00];
				const labels = {};

				const labelRegex = /^[A-Za-z_][A-Za-z0-9_]*$/;

				for (let line of str.split("\n")) {
					line = line.split("#")[0].trim();

					if (line == "") {
						continue;
					}

					if (line.endsWith(":")) {
						const label = line.slice(0, line.length - 1);

						if (!labelRegex.test(label)) {
							throw `Invalid label "${label}"`;
						}

						if (label in labels) {
							throw `Duplicate label "${label}"`;
						}

						labels[label] = bytecode.length;
						continue;
					}

					const args = line.split(/\s+/);
					const op = args.shift();

					if (!(op in ops)) {
						throw `Unknown op "${op}"`;
					}

					bytecode.push(ops[op]);

					for (const arg of args) {
						if (arg.startsWith("r")) {
							const reg = +arg.slice(1);
							if (Number.isInteger(reg) && reg >= 0 && reg <= 255) {
								bytecode.push(reg);
							}
						} else if (!isNaN(+arg)) {
							const imm = new Float32Array([+arg]);
							const view = new DataView(imm.buffer);
							bytecode.push(
								view.getUint8(3),
								view.getUint8(2),
								view.getUint8(1),
								view.getUint8(0));
						} else if (labelRegex.test(arg)) {
							bytecode.push(
								0,
								0,
								0,
								arg);
						} else {
							throw `Invalid argument "${arg}"`;
						}
					}
				}

				for (let i = 0; i < 8; i++) {
					bytecode.push(0xff);
				}

				for (let i = 0; i < bytecode.length; i++) {
					if (typeof bytecode[i] == "string") {
						if (!(bytecode[i] in labels)) {
							throw `Couldn't find label "${bytecode[i]}"`;
						}

						const pos = labels[bytecode[i]];
						bytecode[i - 3] = (pos >> 24) & 0xff;
						bytecode[i - 2] = (pos >> 16) & 0xff;
						bytecode[i - 1] = (pos >> 8) & 0xff;
						bytecode[i] = pos & 0xff;
					}
				}

				const len = getLen(bytecode);
				if (len > 0x4000) {
					throw `Bytecode too large (${len} bytes, max ${0x4000})`;
				}

				bytecode[0] = getCrc(bytecode, len);

				return new Uint8Array(bytecode);
			}
		</script>
	</head>
	<body>
		<div id="loading">
			Loading...
		</div>
		<div id="main" style="display: none">
			<textarea id="bytecode" rows="40" cols="80" spellcheck="false"></textarea>
			<br />
			<button id="submit"> Upload </button>
			<span id="response"></span>
		</div>

		<script>
			const loadingEl = document.getElementById("loading");
			const mainEl = document.getElementById("main");
			const bytecodeEl = document.getElementById("bytecode");
			const submitEl = document.getElementById("submit");
			const responseEl = document.getElementById("response");

			fetch("/ops.h").then((res) => {
				return res.text();
			}).then((str) => {
				for (const line of str.split("\n")) {
					if (line == "" || line.startsWith("OP_NONE")) {
						continue;
					}

					const [_, opcode, name] = line.match(/\((\w+), (\w+)\)/);
					ops[name] = +opcode;
				}

				loadingEl.style.display = "none";
				mainEl.style.display = "block";
			});


			submitEl.addEventListener("click", (evt) => {
				responseEl.innerText = "";

				let bytecode;

				try {
					bytecode = assemble(bytecodeEl.value);
				} catch (err) {
					responseEl.style.color = "red";
					responseEl.innerText = err;
					return;
				}

				fetch("/bytecode.bin", {
					method: "PUT",
					body: bytecode
				}).then((res) => {
					return res.text();
				}).then((text) => {
					responseEl.style.color = "black";
					responseEl.innerText = text;
				});
			});
		</script>
	</body>
</html>
